<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RetailSync â€” Comparative API Architecture Study</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/theme/black.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --soap-color: #1565C0;
            --rest-color: #2E7D32;
            --graphql-color: #7B1FA2;
            --grpc-color: #E65100;
            --bg-dark: #0f0f1a;
            --bg-card: rgba(255,255,255,0.06);
            --text-primary: #e8e8f0;
            --text-secondary: #9e9eb8;
            --accent: #7c5cf7;
        }
        .reveal {
            font-family: 'Inter', sans-serif;
            color: var(--text-primary);
        }
        .reveal .slides { text-align: left; }
        .reveal .slides section { padding: 30px 50px; }
        .reveal h1 { font-size: 2.4em; font-weight: 700; margin-bottom: 0.3em; letter-spacing: -0.02em; }
        .reveal h2 { font-size: 1.7em; font-weight: 600; margin-bottom: 0.4em; letter-spacing: -0.01em; }
        .reveal h3 { font-size: 1.2em; font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5em; }
        .reveal p, .reveal li { font-size: 0.75em; line-height: 1.6; color: var(--text-secondary); }
        .reveal ul { list-style: none; padding-left: 0; }
        .reveal ul li::before { content: "â†’ "; color: var(--accent); font-weight: 600; }
        .reveal strong { color: var(--text-primary); font-weight: 600; }
        .reveal code {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-card);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.85em;
        }
        .reveal .slide-number { font-family: 'Inter', sans-serif; font-size: 12px; }

        /* Title slide */
        .title-slide h1 {
            font-size: 2.8em;
            background: linear-gradient(135deg, #7c5cf7, #00d2ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .title-slide .subtitle {
            font-size: 1.1em;
            color: var(--text-secondary);
            margin-top: 0.5em;
        }
        .title-slide .meta {
            font-size: 0.7em;
            color: #666;
            margin-top: 2em;
        }

        /* Section title slides */
        .section-title {
            text-align: center !important;
        }
        .section-title h2 {
            font-size: 2.2em;
            margin-bottom: 0.2em;
        }
        .section-title .section-number {
            font-size: 4em;
            font-weight: 700;
            opacity: 0.15;
            position: absolute;
            top: 15%;
            right: 10%;
        }

        /* Color bars */
        .soap-bar { border-left: 4px solid var(--soap-color); padding-left: 18px; }
        .rest-bar { border-left: 4px solid var(--rest-color); padding-left: 18px; }
        .graphql-bar { border-left: 4px solid var(--graphql-color); padding-left: 18px; }
        .grpc-bar { border-left: 4px solid var(--grpc-color); padding-left: 18px; }

        /* Tags */
        .tag {
            display: inline-block;
            padding: 3px 12px;
            border-radius: 20px;
            font-size: 0.65em;
            font-weight: 600;
            margin-right: 6px;
            color: white;
        }
        .tag-soap { background: var(--soap-color); }
        .tag-rest { background: var(--rest-color); }
        .tag-graphql { background: var(--graphql-color); }
        .tag-grpc { background: var(--grpc-color); }

        /* Cards */
        .card-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-top: 16px;
        }
        .card {
            background: var(--bg-card);
            border-radius: 10px;
            padding: 18px 20px;
            border: 1px solid rgba(255,255,255,0.08);
        }
        .card h4 {
            font-size: 0.85em;
            font-weight: 600;
            margin: 0 0 8px 0;
        }
        .card p, .card li {
            font-size: 0.65em !important;
            margin: 0;
        }

        /* Comparison table */
        .reveal table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.6em;
            margin-top: 12px;
        }
        .reveal table th {
            background: var(--bg-card);
            padding: 8px 10px;
            text-align: left;
            font-weight: 600;
            color: var(--text-primary);
            border-bottom: 2px solid rgba(255,255,255,0.15);
        }
        .reveal table td {
            padding: 7px 10px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
            color: var(--text-secondary);
        }
        .reveal table tr:hover td { background: rgba(255,255,255,0.03); }

        /* Diagram image */
        .diagram-container {
            text-align: center;
            margin: 12px 0;
        }
        .diagram-container img {
            max-height: 420px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* Trade-off bar */
        .tradeoff {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-card);
            border-radius: 8px;
            padding: 10px 20px;
            margin: 6px 0;
            font-size: 0.65em;
        }
        .tradeoff .gained { color: #4CAF50; font-weight: 600; }
        .tradeoff .sacrificed { color: #ef5350; font-weight: 600; }
        .tradeoff .arrow { color: var(--text-secondary); }

        /* Insight box */
        .insight {
            background: linear-gradient(135deg, rgba(124,92,247,0.12), rgba(0,210,255,0.08));
            border: 1px solid rgba(124,92,247,0.3);
            border-radius: 10px;
            padding: 14px 18px;
            margin-top: 12px;
            font-size: 0.7em;
            line-height: 1.5;
            color: var(--text-primary);
        }
        .insight::before { content: "ðŸ’¡ "; }

        /* Speaker notes styling */
        .reveal .speaker-controls-notes { font-family: 'Inter', sans-serif; }

        /* Key metric */
        .metric {
            text-align: center;
            padding: 12px;
        }
        .metric .number {
            font-size: 2.5em;
            font-weight: 700;
            background: linear-gradient(135deg, #7c5cf7, #00d2ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .metric .label {
            font-size: 0.7em;
            color: var(--text-secondary);
        }

        /* Full screen centered */
        .centered { text-align: center !important; }
    </style>
</head>
<body>
<div class="reveal">
<div class="slides">

<!-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— -->
<!-- â•‘ SLIDE 1: TITLE                                              â•‘ -->
<!-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section class="title-slide centered">
    <h1>RetailSync</h1>
    <p class="subtitle">A Comparative Architectural Study of SOAP, REST, GraphQL, and gRPC<br>in a Global Retail Ecosystem</p>
    <div style="margin-top: 1.5em;">
        <span class="tag tag-soap">SOAP</span>
        <span class="tag tag-rest">REST</span>
        <span class="tag tag-graphql">GraphQL</span>
        <span class="tag tag-grpc">gRPC</span>
    </div>
    <p class="meta">Service-Oriented Computing Module â€” February 2026</p>
    <aside class="notes">
        Welcome. Today we present RetailSync â€” a proof-of-concept that implements four distinct API paradigms within a single retail supply chain. The goal is NOT to declare a winner, but to demonstrate that each paradigm excels in a specific context.
    </aside>
</section>

<!-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— -->
<!-- â•‘ SLIDE 2: AGENDA                                             â•‘ -->
<!-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section>
    <h2>Agenda</h2>
    <table>
        <tr><td style="width:40px;color:var(--accent);font-weight:700;">01</td><td><strong>Context & Motivation</strong> â€” Why four paradigms in one system?</td><td style="color:#666;font-size:0.85em">2 min</td></tr>
        <tr><td style="color:var(--accent);font-weight:700;">02</td><td><strong>System Architecture</strong> â€” Master diagram & data flows</td><td style="color:#666;font-size:0.85em">3 min</td></tr>
        <tr><td style="color:var(--accent);font-weight:700;">03</td><td><strong>Deep Dive</strong> â€” Each module: contract, flow, trade-offs</td><td style="color:#666;font-size:0.85em">8 min</td></tr>
        <tr><td style="color:var(--accent);font-weight:700;">04</td><td><strong>Cross-Paradigm Analysis</strong> â€” Decision tree, payload, aggregation</td><td style="color:#666;font-size:0.85em">3 min</td></tr>
        <tr><td style="color:var(--accent);font-weight:700;">05</td><td><strong>Comparison Matrix & Takeaways</strong></td><td style="color:#666;font-size:0.85em">2 min</td></tr>
    </table>
    <aside class="notes">
        Here is our plan for the next 18 minutes. We'll start with context, show the big picture, then deep-dive into each module before comparing them side by side.
    </aside>
</section>

<!-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— -->
<!-- â•‘ SECTION 1: CONTEXT & MOTIVATION                             â•‘ -->
<!-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section class="section-title">
    <div class="section-number">01</div>
    <h2>Context & Motivation</h2>
    <h3>Why four paradigms in one system?</h3>
</section>

<section>
    <h2>The Retail Problem</h2>
    <p style="font-size:0.85em;color:var(--text-primary);">A global retail brand must communicate with <strong>four fundamentally different stakeholders</strong>, each with distinct technical constraints:</p>
    <div class="card-grid">
        <div class="card soap-bar">
            <h4 style="color:var(--soap-color);">Manufacturers (China/Europe)</h4>
            <p>Legacy ERP systems (SAP, Oracle) that speak SOAP/XML natively. Cannot impose REST.</p>
        </div>
        <div class="card rest-bar">
            <h4 style="color:var(--rest-color);">Partner Boutiques</h4>
            <p>Third-party developers need the simplest possible integration. HTTP + JSON, no SDK.</p>
        </div>
        <div class="card graphql-bar">
            <h4 style="color:var(--graphql-color);">Store Managers</h4>
            <p>Internal dashboards aggregating inventory, orders, and robot telemetry in one view.</p>
        </div>
        <div class="card grpc-bar">
            <h4 style="color:var(--grpc-color);">Warehouse Robots</h4>
            <p>100+ robots streaming telemetry at 10 msg/sec. Bandwidth and latency are critical.</p>
        </div>
    </div>
    <div class="insight">No single paradigm optimally serves all four. The architecture must be polyglot by design.</div>
    <aside class="notes">
        The key insight here is that each stakeholder has fundamentally different constraints. A manufacturer with SAP cannot adopt GraphQL. A boutique developer doesn't want to deal with Protobuf compilation. A dashboard that queries three services individually would suffer from the N+1 problem. And warehouse robots need sub-50-byte binary payloads, not verbose XML. The architecture must speak the right language for each audience.
    </aside>
</section>

<section>
    <h2>Our Approach: Contract-First</h2>
    <p style="font-size:0.85em;">Every module follows a <strong>contract-first</strong> methodology:</p>
    <div class="card-grid">
        <div class="card">
            <h4>1. Define the Contract</h4>
            <p>WSDL, OpenAPI, GraphQL SDL, or Protobuf â€” written <strong>before</strong> any code</p>
        </div>
        <div class="card">
            <h4>2. Implement the Mock</h4>
            <p>Server returns realistic data conforming to the contract</p>
        </div>
        <div class="card">
            <h4>3. Validate with Tests</h4>
            <p>Postman collection + automated assertions for each endpoint</p>
        </div>
        <div class="card">
            <h4>4. Analyse Trade-offs</h4>
            <p>What did we gain? What did we sacrifice? Why here?</p>
        </div>
    </div>
    <aside class="notes">
        Our methodology is contract-first. We write the contract â€” whether that's a WSDL, an OpenAPI spec, a GraphQL schema, or a Protobuf IDL â€” before implementing any server code. This mirrors how real distributed teams work: the contract is the shared truth.
    </aside>
</section>

<!-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— -->
<!-- â•‘ SECTION 2: SYSTEM ARCHITECTURE                              â•‘ -->
<!-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section class="section-title">
    <div class="section-number">02</div>
    <h2>System Architecture</h2>
    <h3>Master diagram & data flows</h3>
</section>

<section>
    <h2>RetailSync â€” System Architecture</h2>
    <div class="diagram-container">
        <img src="../diagrams/01_master_architecture.png" alt="Master Architecture">
    </div>
    <p style="font-size:0.7em; text-align:center;">Four services, four protocols, one retail ecosystem. The GraphQL layer acts as an aggregation gateway.</p>
    <aside class="notes">
        This is the big picture. On the left, our four actor types. In the center, our four services â€” each speaking a different protocol on a different port. On the right, the contract files that serve as the single source of truth. Notice the dashed purple arrows: the GraphQL dashboard resolves fields from the other three services. It doesn't own any data â€” it's purely an aggregator.
    </aside>
</section>

<!-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— -->
<!-- â•‘ SECTION 3: DEEP DIVE â€” EACH MODULE                         â•‘ -->
<!-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section class="section-title">
    <div class="section-number">03</div>
    <h2>Deep Dive</h2>
    <h3>Contract â†’ Flow â†’ Trade-offs for each module</h3>
</section>

<!-- â”€â”€ SOAP â”€â”€ -->
<section>
    <h2><span class="tag tag-soap">SOAP</span> B2B Procurement â€” :8001</h2>
    <div class="card-grid">
        <div class="card">
            <h4>Contract</h4>
            <p><code>PurchaseOrder.wsdl</code> â€” XSD-embedded schema with strict type enforcement</p>
            <p>Implemented with <strong>Spyne</strong> (Python SOAP framework)</p>
        </div>
        <div class="card">
            <h4>Why SOAP Here?</h4>
            <ul>
                <li><strong>XSD validation</strong> at the wire level â€” no ambiguous JSON</li>
                <li><strong>WSDL code generation</strong> â€” both parties generate stubs from one file</li>
                <li><strong>WS-Security</strong> â€” message-level encryption for cross-border POs</li>
            </ul>
        </div>
    </div>
    <div class="diagram-container" style="margin-top:8px;">
        <img src="../diagrams/02_soap_sequence.png" alt="SOAP Sequence" style="max-height:280px;">
    </div>
    <aside class="notes">
        For procurement, SOAP is not a legacy choice â€” it's the right tool. Manufacturers run ERP systems that speak SOAP natively. The WSDL is our machine-readable Service Level Agreement: if a message passes XSD validation, both parties can trust its structure. Unlike JSON, XML Schema enforces field ordering, occurrence constraints, and nested types at the wire level.
    </aside>
</section>

<section>
    <h2><span class="tag tag-soap">SOAP</span> Trade-offs & Insight</h2>
    <div class="tradeoff"><span class="gained">âœ“ Strict type safety (XSD)</span> <span class="arrow">â‡„</span> <span class="sacrificed">âœ— Human readability (XML verbose)</span></div>
    <div class="tradeoff"><span class="gained">âœ“ Formal contract (WSDL)</span> <span class="arrow">â‡„</span> <span class="sacrificed">âœ— Simplicity (heavy toolkits)</span></div>
    <div class="tradeoff"><span class="gained">âœ“ WS-Security (message-level)</span> <span class="arrow">â‡„</span> <span class="sacrificed">âœ— Performance (XML parsing slow)</span></div>
    <div class="insight">SOAP's rigidity is deliberate. In B2B procurement, the cost of a malformed purchase order (incorrect quantities, missing manufacturer IDs) far exceeds the cost of XML verbosity. The WSDL acts as a machine-readable SLA.</div>
    <aside class="notes">
        The key trade-off is verbosity vs safety. We sacrifice human readability and parsing speed, but we gain compile-time guarantees that every order has exactly the right fields. In procurement, a single malformed order can cost thousands of euros. This is why SOAP persists in banking, healthcare, and manufacturing.
    </aside>
</section>

<!-- â”€â”€ REST â”€â”€ -->
<section>
    <h2><span class="tag tag-rest">REST</span> Partner Marketplace â€” :8002</h2>
    <div class="card-grid">
        <div class="card">
            <h4>Contract</h4>
            <p><code>openapi.yaml</code> â€” OpenAPI 3.0 specification</p>
            <p>Implemented with <strong>FastAPI</strong> + <strong>Pydantic</strong> models</p>
        </div>
        <div class="card">
            <h4>Why REST Here?</h4>
            <ul>
                <li><strong>Zero integration barrier</strong> â€” any HTTP client, any language</li>
                <li><strong>HTTP caching</strong> â€” CDNs cache GET responses transparently</li>
                <li><strong>Semantic verbs</strong> â€” GET/PATCH/DELETE are self-documenting</li>
            </ul>
        </div>
    </div>
    <div class="diagram-container" style="margin-top:8px;">
        <img src="../diagrams/03_rest_sequence.png" alt="REST Sequence" style="max-height:280px;">
    </div>
    <aside class="notes">
        For the partner marketplace, REST wins on simplicity. A boutique developer can integrate using curl in minutes. Notice we use PATCH, not PUT â€” PATCH sends only the changed fields, reducing bandwidth and eliminating accidental overwrites from stale client state.
    </aside>
</section>

<section>
    <h2><span class="tag tag-rest">REST</span> Trade-offs & Insight</h2>
    <div class="tradeoff"><span class="gained">âœ“ Universal adoption & simplicity</span> <span class="arrow">â‡„</span> <span class="sacrificed">âœ— No built-in schema enforcement</span></div>
    <div class="tradeoff"><span class="gained">âœ“ HTTP caching at CDN/proxy level</span> <span class="arrow">â‡„</span> <span class="sacrificed">âœ— Multiple round-trips (under-fetching)</span></div>
    <div class="tradeoff"><span class="gained">âœ“ Stateless horizontal scaling</span> <span class="arrow">â‡„</span> <span class="sacrificed">âœ— No native streaming</span></div>
    <div class="insight">PATCH vs PUT: with 10,000 boutiques updating stock per minute, the bandwidth difference between full-resource PUT and single-field PATCH is substantial. PATCH sends only the delta.</div>
    <aside class="notes">
        The critical architectural choice here is PATCH over PUT. PUT requires sending the full resource representation â€” meaning a boutique updating stock after a single sale would re-transmit every field. PATCH sends only the delta. At scale, this difference matters.
    </aside>
</section>

<!-- â”€â”€ GraphQL â”€â”€ -->
<section>
    <h2><span class="tag tag-graphql">GraphQL</span> Manager Dashboard â€” :8003</h2>
    <div class="card-grid">
        <div class="card">
            <h4>Contract</h4>
            <p><code>schema.graphql</code> â€” SDL with Store, Inventory, Order, Telemetry types</p>
            <p>Implemented with <strong>Strawberry</strong> + <strong>FastAPI</strong></p>
        </div>
        <div class="card">
            <h4>Why GraphQL Here?</h4>
            <ul>
                <li><strong>Single query</strong> replaces 3 Ã— N REST calls</li>
                <li><strong>Client-driven shape</strong> â€” each widget requests only what it needs</li>
                <li><strong>Aggregator pattern</strong> â€” frontend ignores backend topology</li>
            </ul>
        </div>
    </div>
    <div class="diagram-container" style="margin-top:8px;">
        <img src="../diagrams/04_graphql_sequence.png" alt="GraphQL Sequence" style="max-height:280px;">
    </div>
    <aside class="notes">
        GraphQL solves the N+1 problem. Without it, the dashboard would need separate calls to /stores, /stores/id/inventory, /stores/id/orders for each store. GraphQL collapses this into a single POST. Notice the parallel resolution: the gateway fans out to REST, SOAP, and gRPC simultaneously, then merges the results into one unified response.
    </aside>
</section>

<section>
    <h2><span class="tag tag-graphql">GraphQL</span> Trade-offs & Insight</h2>
    <div class="tradeoff"><span class="gained">âœ“ Single request for nested data</span> <span class="arrow">â‡„</span> <span class="sacrificed">âœ— No HTTP caching (POST-based)</span></div>
    <div class="tradeoff"><span class="gained">âœ“ Client-controlled response shape</span> <span class="arrow">â‡„</span> <span class="sacrificed">âœ— Query complexity analysis needed</span></div>
    <div class="tradeoff"><span class="gained">âœ“ Backend-agnostic aggregation</span> <span class="arrow">â‡„</span> <span class="sacrificed">âœ— Higher server-side complexity</span></div>
    <div class="insight">GraphQL is not a replacement for REST â€” it's a complementary layer. Our GraphQL service owns no data. It acts as an aggregator that fans out to REST, SOAP, and gRPC. Both APIs coexist: boutiques use REST directly, managers use GraphQL.</div>
    <aside class="notes">
        The key personal analysis here: GraphQL and REST coexist by design. We don't force everyone through GraphQL. Boutiques benefit from REST's caching and simplicity. Managers benefit from GraphQL's aggregation. Attempting to serve both through a single paradigm would degrade both experiences.
    </aside>
</section>

<!-- â”€â”€ gRPC â”€â”€ -->
<section>
    <h2><span class="tag tag-grpc">gRPC</span> Warehouse Logistics â€” :50051</h2>
    <div class="card-grid">
        <div class="card">
            <h4>Contract</h4>
            <p><code>warehouse.proto</code> â€” Protocol Buffers IDL with message & service definitions</p>
            <p>Implemented with <strong>grpcio</strong> + <strong>protobuf</strong></p>
        </div>
        <div class="card">
            <h4>Why gRPC Here?</h4>
            <ul>
                <li><strong>~50B Protobuf</strong> vs ~1KB XML â€” 20x bandwidth reduction</li>
                <li><strong>Bi-directional streaming</strong> â€” commands and telemetry on one connection</li>
                <li><strong>Compile-time types</strong> â€” field errors caught before deployment</li>
            </ul>
        </div>
    </div>
    <div class="diagram-container" style="margin-top:8px;">
        <img src="../diagrams/05_grpc_sequence.png" alt="gRPC Sequence" style="max-height:280px;">
    </div>
    <aside class="notes">
        For warehouse automation, every byte counts. Protobuf encodes a telemetry message in about 50 bytes versus 1 kilobyte for the SOAP equivalent. But gRPC is not just about compression â€” it's about the streaming model. Both streams are independent: the controller pushes commands, and the robot pushes telemetry, simultaneously, on a single HTTP/2 connection.
    </aside>
</section>

<section>
    <h2><span class="tag tag-grpc">gRPC</span> Trade-offs & Insight</h2>
    <div class="tradeoff"><span class="gained">âœ“ Binary efficiency (20x smaller)</span> <span class="arrow">â‡„</span> <span class="sacrificed">âœ— Cannot inspect with curl</span></div>
    <div class="tradeoff"><span class="gained">âœ“ Bi-directional streaming</span> <span class="arrow">â‡„</span> <span class="sacrificed">âœ— No browser support (needs gRPC-Web)</span></div>
    <div class="tradeoff"><span class="gained">âœ“ Compile-time type safety</span> <span class="arrow">â‡„</span> <span class="sacrificed">âœ— Smaller ecosystem than REST</span></div>
    <div class="insight">Streaming vs polling: in a unary model, 100 robots Ã— 2 RPCs = 200 connections with polling delays. Bi-directional streaming gives sub-second reaction time â€” the difference between a robot colliding with an obstacle or stopping in time.</div>
    <aside class="notes">
        The personal analysis: the choice here is not just about throughput but about control latency. With polling, there's always a delay between when the controller decides to reroute a robot and when the command actually arrives. With streaming, the command arrives instantly. In a warehouse where robots move at speed, this latency determines safety.
    </aside>
</section>

<!-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— -->
<!-- â•‘ SECTION 4: CROSS-PARADIGM ANALYSIS                         â•‘ -->
<!-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section class="section-title">
    <div class="section-number">04</div>
    <h2>Cross-Paradigm Analysis</h2>
    <h3>Decision logic, payload comparison, aggregation pattern</h3>
</section>

<section>
    <h2>Protocol Selection Logic</h2>
    <div class="diagram-container">
        <img src="../diagrams/06_decision_tree.png" alt="Decision Tree" style="max-height:440px;">
    </div>
    <p style="font-size:0.7em;text-align:center;">REST is the default. We deviate only when a requirement explicitly demands it.</p>
    <aside class="notes">
        This decision tree summarises our architectural reasoning. We start with REST as the default â€” it's the simplest, most widely adopted paradigm. We only deviate when a concrete constraint forces it: strict schemas demand SOAP, streaming demands gRPC, aggregation demands GraphQL. Every non-REST choice is justified by a specific limitation of REST, not by novelty.
    </aside>
</section>

<section>
    <h2>Payload Overhead Comparison</h2>
    <div class="diagram-container">
        <img src="../diagrams/08_payload_comparison.png" alt="Payload Comparison" style="max-height:440px;">
    </div>
    <p style="font-size:0.7em;text-align:center;">Same order object: 1 KB (SOAP) â†’ 200 B (REST) â†’ 50 B (gRPC). 20Ã— reduction.</p>
    <aside class="notes">
        This is the same business data â€” an order with SKU, quantity, and price â€” encoded in three different formats. SOAP wraps it in an envelope with namespaces for about 1 kilobyte. JSON strips the namespaces down to 200 bytes. Protobuf uses varint encoding and field tags for just 50 bytes. At 100 robots at 10 messages per second, this is the difference between saturating a warehouse network and barely using it.
    </aside>
</section>

<section>
    <h2>GraphQL Aggregator Pattern</h2>
    <div class="diagram-container">
        <img src="../diagrams/07_aggregator_pattern.png" alt="Aggregator Pattern" style="max-height:440px;">
    </div>
    <p style="font-size:0.7em;text-align:center;">The frontend sees one typed schema. The backend heterogeneity is invisible.</p>
    <aside class="notes">
        This diagram shows the architectural power of GraphQL as an aggregator. The Store Manager Tablet sends a single POST /graphql request. The gateway maps each field to a different backend: inventory from REST, orders from SOAP, telemetry from gRPC. The frontend developer has no idea which backend uses which protocol â€” they only see a unified, typed schema. If we later migrate orders from SOAP to REST, the frontend changes zero lines of code.
    </aside>
</section>

<!-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— -->
<!-- â•‘ SECTION 5: COMPARISON MATRIX & TAKEAWAYS                   â•‘ -->
<!-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section class="section-title">
    <div class="section-number">05</div>
    <h2>Comparison Matrix & Takeaways</h2>
    <h3>Final side-by-side analysis</h3>
</section>

<section>
    <h2>Final Comparison Matrix</h2>
    <table>
        <thead>
            <tr>
                <th>Criterion</th>
                <th style="color:var(--soap-color);">SOAP</th>
                <th style="color:var(--rest-color);">REST</th>
                <th style="color:var(--graphql-color);">GraphQL</th>
                <th style="color:var(--grpc-color);">gRPC</th>
            </tr>
        </thead>
        <tbody>
            <tr><td><strong>Data Format</strong></td><td>XML</td><td>JSON</td><td>JSON</td><td>Protobuf (binary)</td></tr>
            <tr><td><strong>Transport</strong></td><td>HTTP/1.1</td><td>HTTP/1.1</td><td>HTTP/1.1</td><td>HTTP/2</td></tr>
            <tr><td><strong>Contract</strong></td><td>WSDL (mandatory)</td><td>OpenAPI (optional)</td><td>SDL Schema</td><td>.proto (mandatory)</td></tr>
            <tr><td><strong>Typing</strong></td><td>Strict (XSD)</td><td>Runtime (Pydantic)</td><td>Runtime (resolvers)</td><td>Compile-time (codegen)</td></tr>
            <tr><td><strong>Streaming</strong></td><td>No</td><td>No</td><td>Subscriptions</td><td>Native bi-directional</td></tr>
            <tr><td><strong>Caching</strong></td><td>No</td><td>Yes (HTTP GET)</td><td>No (POST-based)</td><td>No</td></tr>
            <tr><td><strong>Browser Support</strong></td><td>Via AJAX</td><td>Native</td><td>Native</td><td>gRPC-Web proxy</td></tr>
            <tr><td><strong>Best For</strong></td><td>Formal B2B</td><td>Public/partner APIs</td><td>Aggregation gateways</td><td>Machine-to-machine</td></tr>
            <tr><td><strong>Our Port</strong></td><td>:8001</td><td>:8002</td><td>:8003</td><td>:50051</td></tr>
        </tbody>
    </table>
    <aside class="notes">
        This is the side-by-side summary. Notice there is no universally best paradigm â€” each cell represents a design decision with consequences. REST caches but can't stream. gRPC streams but can't be called from a browser. GraphQL aggregates but loses HTTP caching. SOAP enforces schemas but is verbose. The art is matching the paradigm to the constraint.
    </aside>
</section>

<section>
    <h2>Key Takeaways</h2>
    <div class="card-grid">
        <div class="card">
            <h4>1. No Universal Winner</h4>
            <p>Each paradigm excels in its niche. The architecture must be polyglot.</p>
        </div>
        <div class="card">
            <h4>2. Contract-First is Essential</h4>
            <p>WSDL, OpenAPI, SDL, Protobuf â€” the contract is the shared truth between teams.</p>
        </div>
        <div class="card">
            <h4>3. REST as Default, Deviate with Reason</h4>
            <p>Every non-REST choice must be justified by a concrete constraint that REST cannot satisfy.</p>
        </div>
        <div class="card">
            <h4>4. GraphQL as Glue, Not Replacement</h4>
            <p>GraphQL aggregates heterogeneous backends without replacing them. Both REST and GraphQL coexist.</p>
        </div>
    </div>
    <div class="insight" style="margin-top:16px;">The mark of architectural maturity is not knowing the latest framework â€” it is knowing when NOT to use it.</div>
    <aside class="notes">
        If there is one thing to remember from this presentation: the mark of architectural maturity is not knowing the latest framework. It's knowing when NOT to use it. Every technology we didn't choose for a given module is just as important as the one we did choose â€” because the rejection is justified by concrete trade-offs, not by preference.
    </aside>
</section>

<!-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— -->
<!-- â•‘ SLIDE: THANK YOU                                            â•‘ -->
<!-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section class="centered">
    <h1 style="background: linear-gradient(135deg, #7c5cf7, #00d2ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Thank You</h1>
    <h3>Questions?</h3>
    <div style="margin-top: 2em;">
        <span class="tag tag-soap">SOAP :8001</span>
        <span class="tag tag-rest">REST :8002</span>
        <span class="tag tag-graphql">GraphQL :8003</span>
        <span class="tag tag-grpc">gRPC :50051</span>
    </div>
    <p style="margin-top:2em;font-size:0.65em;color:#666;">
        <strong>GitHub:</strong> github.com/AyaMor/omnichain-retail-mesh
    </p>
    <aside class="notes">
        Thank you for your attention. We're now happy to take your questions. We can demonstrate any of the four services live, show the Postman collection, or dive deeper into any trade-off or architectural decision.
    </aside>
</section>

</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/notes/notes.js"></script>
<script>
    Reveal.initialize({
        hash: true,
        slideNumber: 'c/t',
        width: 1280,
        height: 720,
        margin: 0.04,
        transition: 'slide',
        transitionSpeed: 'default',
        plugins: [ RevealNotes ],
        // Press 'S' to open speaker notes in a separate window
    });
</script>
</body>
</html>
